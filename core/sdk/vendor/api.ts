/* tslint:disable */
/* eslint-disable */
/**
 * Vendor Docs
 * Vendor endpoints...
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'role': AccountInfoRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'status': AccountInfoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'referralCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountInfo
     */
    'isProfileUpdated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountInfo
     */
    'isAccountDisabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountInfo
     */
    'isProductUploadSubscriptionActive': boolean;
}

export const AccountInfoRoleEnum = {
    Customer: 'CUSTOMER',
    Farmer: 'FARMER',
    Admin: 'ADMIN'
} as const;

export type AccountInfoRoleEnum = typeof AccountInfoRoleEnum[keyof typeof AccountInfoRoleEnum];
export const AccountInfoStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Inactive: 'inactive',
    ShadowBanned: 'shadow_banned',
    Disabled: 'disabled'
} as const;

export type AccountInfoStatusEnum = typeof AccountInfoStatusEnum[keyof typeof AccountInfoStatusEnum];

/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * Unique identifier slug for the bank
     * @type {string}
     * @memberof Bank
     */
    'slug': string;
    /**
     * Name of the bank
     * @type {string}
     * @memberof Bank
     */
    'name': string;
    /**
     * Unique identifier for the bank
     * @type {number}
     * @memberof Bank
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ChargeResponse
 */
export interface ChargeResponse {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof ChargeResponse
     */
    'status': boolean;
    /**
     * Message describing the result of the operation
     * @type {string}
     * @memberof ChargeResponse
     */
    'message': string;
    /**
     * The charge attempt details
     * @type {ChargeResponseData}
     * @memberof ChargeResponse
     */
    'data': ChargeResponseData;
}
/**
 * 
 * @export
 * @interface ChargeResponseData
 */
export interface ChargeResponseData {
    /**
     * Current status of the charge attempt
     * @type {string}
     * @memberof ChargeResponseData
     */
    'status': string;
    /**
     * Human readable message about the charge
     * @type {string}
     * @memberof ChargeResponseData
     */
    'display_text': string;
    /**
     * Unique reference for this transaction
     * @type {string}
     * @memberof ChargeResponseData
     */
    'reference': string;
    /**
     * Amount to be charged in smallest currency unit
     * @type {number}
     * @memberof ChargeResponseData
     */
    'amount': number;
    /**
     * Name of the account to transfer to
     * @type {string}
     * @memberof ChargeResponseData
     */
    'account_name': string;
    /**
     * Account number to transfer to
     * @type {string}
     * @memberof ChargeResponseData
     */
    'account_number': string;
    /**
     * Bank details for the transfer
     * @type {Bank}
     * @memberof ChargeResponseData
     */
    'bank': Bank;
    /**
     * ISO timestamp when the account details expire
     * @type {string}
     * @memberof ChargeResponseData
     */
    'account_expires_at': string;
}
/**
 * 
 * @export
 * @interface CreatePremiumSubscriptionDto
 */
export interface CreatePremiumSubscriptionDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePremiumSubscriptionDto
     */
    'payment_gateway': CreatePremiumSubscriptionDtoPaymentGatewayEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePremiumSubscriptionDto
     */
    'payment_date': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePremiumSubscriptionDto
     */
    'payment_reference': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePremiumSubscriptionDto
     */
    'payment_method': string;
}

export const CreatePremiumSubscriptionDtoPaymentGatewayEnum = {
    Paystack: 'PAYSTACK',
    Googlepay: 'GOOGLEPAY',
    Applepay: 'APPLEPAY',
    Buypower: 'BUYPOWER'
} as const;

export type CreatePremiumSubscriptionDtoPaymentGatewayEnum = typeof CreatePremiumSubscriptionDtoPaymentGatewayEnum[keyof typeof CreatePremiumSubscriptionDtoPaymentGatewayEnum];

/**
 * 
 * @export
 * @interface CreateProductDto
 */
export interface CreateProductDto {
    /**
     * The name of the product
     * @type {string}
     * @memberof CreateProductDto
     */
    'name': string;
    /**
     * The price of the product
     * @type {string}
     * @memberof CreateProductDto
     */
    'price': string;
    /**
     * The discount price of the product
     * @type {string}
     * @memberof CreateProductDto
     */
    'discountPrice': string;
    /**
     * Whether the product is negotiable
     * @type {boolean}
     * @memberof CreateProductDto
     */
    'isNegotiable': boolean;
    /**
     * Whether the product is in stock
     * @type {boolean}
     * @memberof CreateProductDto
     */
    'inStock': boolean;
    /**
     * Array of product media
     * @type {Array<ProductMediaDto>}
     * @memberof CreateProductDto
     */
    'media': Array<ProductMediaDto>;
    /**
     * The category of the product
     * @type {string}
     * @memberof CreateProductDto
     */
    'category': CreateProductDtoCategoryEnum;
    /**
     * The description of the product
     * @type {string}
     * @memberof CreateProductDto
     */
    'description': string;
}

export const CreateProductDtoCategoryEnum = {
    Guineapig: 'GUINEAPIG',
    Cat: 'CAT',
    Dog: 'DOG',
    Goat: 'GOAT',
    Pig: 'PIG',
    Sheep: 'SHEEP',
    Fish: 'FISH',
    Rabbit: 'RABBIT',
    Snail: 'SNAIL',
    Cow: 'COW',
    Chicken: 'CHICKEN',
    Bird: 'BIRD',
    Turkey: 'TURKEY',
    Grasscutter: 'GRASSCUTTER'
} as const;

export type CreateProductDtoCategoryEnum = typeof CreateProductDtoCategoryEnum[keyof typeof CreateProductDtoCategoryEnum];

/**
 * 
 * @export
 * @interface CreateProductUploadSubscriptionDto
 */
export interface CreateProductUploadSubscriptionDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProductUploadSubscriptionDto
     */
    'payment_gateway': CreateProductUploadSubscriptionDtoPaymentGatewayEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateProductUploadSubscriptionDto
     */
    'payment_reference': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductUploadSubscriptionDto
     */
    'payment_method': string;
}

export const CreateProductUploadSubscriptionDtoPaymentGatewayEnum = {
    Paystack: 'PAYSTACK',
    Googlepay: 'GOOGLEPAY',
    Applepay: 'APPLEPAY',
    Buypower: 'BUYPOWER'
} as const;

export type CreateProductUploadSubscriptionDtoPaymentGatewayEnum = typeof CreateProductUploadSubscriptionDtoPaymentGatewayEnum[keyof typeof CreateProductUploadSubscriptionDtoPaymentGatewayEnum];

/**
 * 
 * @export
 * @interface CreatePromotionDto
 */
export interface CreatePromotionDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePromotionDto
     */
    'payment_gateway': CreatePromotionDtoPaymentGatewayEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePromotionDto
     */
    'payment_date': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePromotionDto
     */
    'payment_reference': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePromotionDto
     */
    'amount_paid': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePromotionDto
     */
    'payment_method': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreatePromotionDto
     */
    'product_ids': Array<number>;
}

export const CreatePromotionDtoPaymentGatewayEnum = {
    Paystack: 'PAYSTACK',
    Googlepay: 'GOOGLEPAY',
    Applepay: 'APPLEPAY',
    Buypower: 'BUYPOWER'
} as const;

export type CreatePromotionDtoPaymentGatewayEnum = typeof CreatePromotionDtoPaymentGatewayEnum[keyof typeof CreatePromotionDtoPaymentGatewayEnum];

/**
 * 
 * @export
 * @interface InitializePaymentSessionResponse
 */
export interface InitializePaymentSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof InitializePaymentSessionResponse
     */
    'secureUrl': string;
    /**
     * 
     * @type {string}
     * @memberof InitializePaymentSessionResponse
     */
    'reference': string;
}
/**
 * 
 * @export
 * @interface MediaInfo
 */
export interface MediaInfo {
    /**
     * 
     * @type {string}
     * @memberof MediaInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MediaInfo
     */
    'mediaUrl': string;
    /**
     * The type of media
     * @type {string}
     * @memberof MediaInfo
     */
    'mediaType': MediaInfoMediaTypeEnum;
}

export const MediaInfoMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Pdf: 'PDF'
} as const;

export type MediaInfoMediaTypeEnum = typeof MediaInfoMediaTypeEnum[keyof typeof MediaInfoMediaTypeEnum];

/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'value': PaymentMethodValueEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'gateway': PaymentMethodGatewayEnum;
}

export const PaymentMethodValueEnum = {
    None: 'NONE',
    Wallet: 'WALLET',
    Card: 'CARD',
    Transfer: 'TRANSFER',
    Other: 'OTHER',
    Banktransfer: 'BANKTRANSFER'
} as const;

export type PaymentMethodValueEnum = typeof PaymentMethodValueEnum[keyof typeof PaymentMethodValueEnum];
export const PaymentMethodGatewayEnum = {
    Paystack: 'PAYSTACK',
    Googlepay: 'GOOGLEPAY',
    Applepay: 'APPLEPAY',
    Buypower: 'BUYPOWER'
} as const;

export type PaymentMethodGatewayEnum = typeof PaymentMethodGatewayEnum[keyof typeof PaymentMethodGatewayEnum];

/**
 * 
 * @export
 * @interface PremiumSubscriptionInfo
 */
export interface PremiumSubscriptionInfo {
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'subscription_date': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'expiration_date': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'payment_method': string;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionInfo
     */
    'amount_paid': number;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'payment_reference': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'payment_gateway': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionInfo
     */
    'payment_date': string;
    /**
     * 
     * @type {boolean}
     * @memberof PremiumSubscriptionInfo
     */
    'isExpired': boolean;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionInfo
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionInfo
     */
    'plan': number;
}
/**
 * 
 * @export
 * @interface PremiumSubscriptionPlanDescription
 */
export interface PremiumSubscriptionPlanDescription {
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'duration': string;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'duration_days': number;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'bonus_days': number;
    /**
     * 
     * @type {number}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'position': number;
    /**
     * 
     * @type {Array<PremiumSubscriptionPlanInfoDescription>}
     * @memberof PremiumSubscriptionPlanDescription
     */
    'info': Array<PremiumSubscriptionPlanInfoDescription>;
}
/**
 * 
 * @export
 * @interface PremiumSubscriptionPlanInfoDescription
 */
export interface PremiumSubscriptionPlanInfoDescription {
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionPlanInfoDescription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionPlanInfoDescription
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PremiumSubscriptionResponse
 */
export interface PremiumSubscriptionResponse {
    /**
     * 
     * @type {PremiumSubscriptionInfo}
     * @memberof PremiumSubscriptionResponse
     */
    'subscription': PremiumSubscriptionInfo;
    /**
     * 
     * @type {VendorInfo}
     * @memberof PremiumSubscriptionResponse
     */
    'vendorInfo': VendorInfo;
}
/**
 * 
 * @export
 * @interface PremiumSubscriptionUpdateVendorProfileDto
 */
export interface PremiumSubscriptionUpdateVendorProfileDto {
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'facebookUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'instagramUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PremiumSubscriptionUpdateVendorProfileDto
     */
    'twitterUrl'?: string;
}
/**
 * 
 * @export
 * @interface ProductMediaDto
 */
export interface ProductMediaDto {
    /**
     * The URL of the product image
     * @type {string}
     * @memberof ProductMediaDto
     */
    'mediaUrl': string;
    /**
     * The type of the product media
     * @type {string}
     * @memberof ProductMediaDto
     */
    'mediaType': ProductMediaDtoMediaTypeEnum;
}

export const ProductMediaDtoMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Pdf: 'PDF'
} as const;

export type ProductMediaDtoMediaTypeEnum = typeof ProductMediaDtoMediaTypeEnum[keyof typeof ProductMediaDtoMediaTypeEnum];

/**
 * 
 * @export
 * @interface ProductUploadSubscriptionInfo
 */
export interface ProductUploadSubscriptionInfo {
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'subscription_date': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'expiration_date': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'payment_method': string;
    /**
     * 
     * @type {number}
     * @memberof ProductUploadSubscriptionInfo
     */
    'amount_paid': number;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'payment_reference': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'payment_gateway': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionInfo
     */
    'payment_date': string;
    /**
     * 
     * @type {number}
     * @memberof ProductUploadSubscriptionInfo
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof ProductUploadSubscriptionInfo
     */
    'plan': number;
}
/**
 * 
 * @export
 * @interface ProductUploadSubscriptionPlanInfo
 */
export interface ProductUploadSubscriptionPlanInfo {
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionPlanInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionPlanInfo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProductUploadSubscriptionPlanInfo
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ProductUploadSubscriptionPlanInfo
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ProductUploadSubscriptionPlanInfo
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface PromotionDescriptionPlanInfo
 */
export interface PromotionDescriptionPlanInfo {
    /**
     * 
     * @type {string}
     * @memberof PromotionDescriptionPlanInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionDescriptionPlanInfo
     */
    'duration': PromotionDescriptionPlanInfoDurationEnum;
    /**
     * 
     * @type {string}
     * @memberof PromotionDescriptionPlanInfo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionDescriptionPlanInfo
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PromotionDescriptionPlanInfo
     */
    'price': number;
}

export const PromotionDescriptionPlanInfoDurationEnum = {
    Weekly: 'WEEKLY',
    TwoWeeks: 'TWO_WEEKS',
    Monthly: 'MONTHLY'
} as const;

export type PromotionDescriptionPlanInfoDurationEnum = typeof PromotionDescriptionPlanInfoDurationEnum[keyof typeof PromotionDescriptionPlanInfoDurationEnum];

/**
 * 
 * @export
 * @interface PromotionInfo
 */
export interface PromotionInfo {
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'subscription_date': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'expiration_date': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'payment_method': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'amount_paid': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'payment_reference': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'payment_gateway': PromotionInfoPaymentGatewayEnum;
    /**
     * 
     * @type {string}
     * @memberof PromotionInfo
     */
    'payment_date': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PromotionInfo
     */
    'products': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof PromotionInfo
     */
    'isReferral': boolean;
    /**
     * 
     * @type {PromotionDescriptionPlanInfo}
     * @memberof PromotionInfo
     */
    'plan': PromotionDescriptionPlanInfo;
}

export const PromotionInfoPaymentGatewayEnum = {
    Paystack: 'PAYSTACK',
    Googlepay: 'GOOGLEPAY',
    Applepay: 'APPLEPAY',
    Buypower: 'BUYPOWER'
} as const;

export type PromotionInfoPaymentGatewayEnum = typeof PromotionInfoPaymentGatewayEnum[keyof typeof PromotionInfoPaymentGatewayEnum];

/**
 * 
 * @export
 * @interface PromotionPlanDescription
 */
export interface PromotionPlanDescription {
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanDescription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanDescription
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanDescription
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanDescription
     */
    'duration': PromotionPlanDescriptionDurationEnum;
    /**
     * 
     * @type {number}
     * @memberof PromotionPlanDescription
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof PromotionPlanDescription
     */
    'discount_price': number;
    /**
     * 
     * @type {number}
     * @memberof PromotionPlanDescription
     */
    'product_count': number;
    /**
     * 
     * @type {number}
     * @memberof PromotionPlanDescription
     */
    'duration_days': number;
    /**
     * 
     * @type {number}
     * @memberof PromotionPlanDescription
     */
    'bonus_days': number;
    /**
     * 
     * @type {number}
     * @memberof PromotionPlanDescription
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanDescription
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<PromotionPlanInfoDescription>}
     * @memberof PromotionPlanDescription
     */
    'info': Array<PromotionPlanInfoDescription>;
}

export const PromotionPlanDescriptionDurationEnum = {
    Weekly: 'WEEKLY',
    TwoWeeks: 'TWO_WEEKS',
    Monthly: 'MONTHLY'
} as const;

export type PromotionPlanDescriptionDurationEnum = typeof PromotionPlanDescriptionDurationEnum[keyof typeof PromotionPlanDescriptionDurationEnum];

/**
 * 
 * @export
 * @interface PromotionPlanInfoDescription
 */
export interface PromotionPlanInfoDescription {
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanInfoDescription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanInfoDescription
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPlanInfoDescription
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PromotionsInfo
 */
export interface PromotionsInfo {
    /**
     * 
     * @type {Array<PromotionInfo>}
     * @memberof PromotionsInfo
     */
    'promotions': Array<PromotionInfo>;
}
/**
 * 
 * @export
 * @interface UpdateProductDto
 */
export interface UpdateProductDto {
    /**
     * The name of the product
     * @type {string}
     * @memberof UpdateProductDto
     */
    'name': string;
    /**
     * The price of the product
     * @type {string}
     * @memberof UpdateProductDto
     */
    'price': string;
    /**
     * The discount price of the product
     * @type {string}
     * @memberof UpdateProductDto
     */
    'discountPrice': string;
    /**
     * Whether the product is negotiable
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'isNegotiable': boolean;
    /**
     * Whether the product is in stock
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'inStock': boolean;
    /**
     * Array of product media
     * @type {Array<ProductMediaDto>}
     * @memberof UpdateProductDto
     */
    'media': Array<ProductMediaDto>;
    /**
     * The category of the product
     * @type {string}
     * @memberof UpdateProductDto
     */
    'category': UpdateProductDtoCategoryEnum;
    /**
     * The description of the product
     * @type {string}
     * @memberof UpdateProductDto
     */
    'description': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateProductDto
     */
    'removedMediaIds': Array<number>;
}

export const UpdateProductDtoCategoryEnum = {
    Guineapig: 'GUINEAPIG',
    Cat: 'CAT',
    Dog: 'DOG',
    Goat: 'GOAT',
    Pig: 'PIG',
    Sheep: 'SHEEP',
    Fish: 'FISH',
    Rabbit: 'RABBIT',
    Snail: 'SNAIL',
    Cow: 'COW',
    Chicken: 'CHICKEN',
    Bird: 'BIRD',
    Turkey: 'TURKEY',
    Grasscutter: 'GRASSCUTTER'
} as const;

export type UpdateProductDtoCategoryEnum = typeof UpdateProductDtoCategoryEnum[keyof typeof UpdateProductDtoCategoryEnum];

/**
 * 
 * @export
 * @interface UpdateUserRoleResponse
 */
export interface UpdateUserRoleResponse {
    /**
     * 
     * @type {VendorInfo}
     * @memberof UpdateUserRoleResponse
     */
    'vendorInfo': VendorInfo;
    /**
     * 
     * @type {AccountInfo}
     * @memberof UpdateUserRoleResponse
     */
    'accountInfo': AccountInfo;
}
/**
 * 
 * @export
 * @interface UpdateVendorProfileDto
 */
export interface UpdateVendorProfileDto {
    /**
     * The name of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'name': string;
    /**
     * The address of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'address': string;
    /**
     * The avatar of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'avatar': string;
    /**
     * The phone number of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'phoneNumber': string;
    /**
     * The email of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'email': string;
    /**
     * The zip postal code of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'state': string;
    /**
     * The zip postal code of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileDto
     */
    'city': string;
}
/**
 * 
 * @export
 * @interface UpdateVendorProfileLogoDto
 */
export interface UpdateVendorProfileLogoDto {
    /**
     * The avatar of the vendor
     * @type {string}
     * @memberof UpdateVendorProfileLogoDto
     */
    'avatar': string;
}
/**
 * 
 * @export
 * @interface UserPromotionPlanDescription
 */
export interface UserPromotionPlanDescription {
    /**
     * 
     * @type {string}
     * @memberof UserPromotionPlanDescription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserPromotionPlanDescription
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UserPromotionPlanDescription
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UserPromotionPlanDescription
     */
    'duration': UserPromotionPlanDescriptionDurationEnum;
    /**
     * 
     * @type {number}
     * @memberof UserPromotionPlanDescription
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof UserPromotionPlanDescription
     */
    'discount_price': number;
    /**
     * 
     * @type {number}
     * @memberof UserPromotionPlanDescription
     */
    'product_count': number;
    /**
     * 
     * @type {number}
     * @memberof UserPromotionPlanDescription
     */
    'duration_days': number;
    /**
     * 
     * @type {number}
     * @memberof UserPromotionPlanDescription
     */
    'bonus_days': number;
}

export const UserPromotionPlanDescriptionDurationEnum = {
    Weekly: 'WEEKLY',
    TwoWeeks: 'TWO_WEEKS',
    Monthly: 'MONTHLY'
} as const;

export type UserPromotionPlanDescriptionDurationEnum = typeof UserPromotionPlanDescriptionDurationEnum[keyof typeof UserPromotionPlanDescriptionDurationEnum];

/**
 * 
 * @export
 * @interface UserPromotionPlanInfo
 */
export interface UserPromotionPlanInfo {
    /**
     * 
     * @type {string}
     * @memberof UserPromotionPlanInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserPromotionPlanInfo
     */
    'user': string;
    /**
     * 
     * @type {UserPromotionPlanDescription}
     * @memberof UserPromotionPlanInfo
     */
    'plan': UserPromotionPlanDescription;
}
/**
 * 
 * @export
 * @interface VendorInfo
 */
export interface VendorInfo {
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'vendorId': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'phoneNumber': string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorInfo
     */
    'isUpdated': boolean;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof VendorInfo
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface VendorProductInfo
 */
export interface VendorProductInfo {
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof VendorProductInfo
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof VendorProductInfo
     */
    'discountPrice': number;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'category': VendorProductInfoCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof VendorProductInfo
     */
    'isNegotiable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VendorProductInfo
     */
    'inStock': boolean;
    /**
     * 
     * @type {number}
     * @memberof VendorProductInfo
     */
    'viewCount': number;
    /**
     * 
     * @type {number}
     * @memberof VendorProductInfo
     */
    'likeCount': number;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'impressionCount': string;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'coverPhoto': string;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'videoUrl'?: string;
    /**
     * 
     * @type {Array<MediaInfo>}
     * @memberof VendorProductInfo
     */
    'media': Array<MediaInfo>;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof VendorProductInfo
     */
    'updatedAt': string;
}

export const VendorProductInfoCategoryEnum = {
    Guineapig: 'GUINEAPIG',
    Cat: 'CAT',
    Dog: 'DOG',
    Goat: 'GOAT',
    Pig: 'PIG',
    Sheep: 'SHEEP',
    Fish: 'FISH',
    Rabbit: 'RABBIT',
    Snail: 'SNAIL',
    Cow: 'COW',
    Chicken: 'CHICKEN',
    Bird: 'BIRD',
    Turkey: 'TURKEY',
    Grasscutter: 'GRASSCUTTER'
} as const;

export type VendorProductInfoCategoryEnum = typeof VendorProductInfoCategoryEnum[keyof typeof VendorProductInfoCategoryEnum];

/**
 * 
 * @export
 * @interface VendorProductsResponse
 */
export interface VendorProductsResponse {
    /**
     * 
     * @type {Array<VendorProductInfo>}
     * @memberof VendorProductsResponse
     */
    'products': Array<VendorProductInfo>;
    /**
     * 
     * @type {number}
     * @memberof VendorProductsResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof VendorProductsResponse
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface VerifyPaymentSessionResponse
 */
export interface VerifyPaymentSessionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof VerifyPaymentSessionResponse
     */
    'status': boolean;
    /**
     * 
     * @type {string}
     * @memberof VerifyPaymentSessionResponse
     */
    'paid_at': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyPaymentSessionResponse
     */
    'channel': string;
}

/**
 * PayableApi - axios parameter creator
 * @export
 */
export const PayableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerInitializePremiumSubscriptionTransferSession: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('payableControllerInitializePremiumSubscriptionTransferSession', 'planId', planId)
            const localVarPath = `/v1/vendor/payable/initialize-premium-transfer-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerInitializeProductUploadSubscriptionTransferSession: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('payableControllerInitializeProductUploadSubscriptionTransferSession', 'planId', planId)
            const localVarPath = `/v1/vendor/payable/initialize-product-upload-transfer-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerInitializePromotionSubscriptionTransferSession: async (planId: number, productIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('payableControllerInitializePromotionSubscriptionTransferSession', 'planId', planId)
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('payableControllerInitializePromotionSubscriptionTransferSession', 'productIds', productIds)
            const localVarPath = `/v1/vendor/payable/initialize-promotion-transfer-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerVerifyPaymentSession: async (paymentReference: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentReference' is not null or undefined
            assertParamExists('payableControllerVerifyPaymentSession', 'paymentReference', paymentReference)
            const localVarPath = `/v1/vendor/payable/verify-payment-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paymentReference !== undefined) {
                localVarQueryParameter['paymentReference'] = paymentReference;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayableApi - functional programming interface
 * @export
 */
export const PayableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayableApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payableControllerInitializePremiumSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payableControllerInitializePremiumSubscriptionTransferSession(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayableApi.payableControllerInitializePremiumSubscriptionTransferSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payableControllerInitializeProductUploadSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payableControllerInitializeProductUploadSubscriptionTransferSession(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayableApi.payableControllerInitializeProductUploadSubscriptionTransferSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payableControllerInitializePromotionSubscriptionTransferSession(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payableControllerInitializePromotionSubscriptionTransferSession(planId, productIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayableApi.payableControllerInitializePromotionSubscriptionTransferSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payableControllerVerifyPaymentSession(paymentReference: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyPaymentSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payableControllerVerifyPaymentSession(paymentReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayableApi.payableControllerVerifyPaymentSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PayableApi - factory interface
 * @export
 */
export const PayableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayableApiFp(configuration)
    return {
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerInitializePremiumSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChargeResponse> {
            return localVarFp.payableControllerInitializePremiumSubscriptionTransferSession(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerInitializeProductUploadSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChargeResponse> {
            return localVarFp.payableControllerInitializeProductUploadSubscriptionTransferSession(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerInitializePromotionSubscriptionTransferSession(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<ChargeResponse> {
            return localVarFp.payableControllerInitializePromotionSubscriptionTransferSession(planId, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerVerifyPaymentSession(paymentReference: string, options?: RawAxiosRequestConfig): AxiosPromise<VerifyPaymentSessionResponse> {
            return localVarFp.payableControllerVerifyPaymentSession(paymentReference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayableApi - object-oriented interface
 * @export
 * @class PayableApi
 * @extends {BaseAPI}
 */
export class PayableApi extends BaseAPI {
    /**
     * 
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayableApi
     */
    public payableControllerInitializePremiumSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig) {
        return PayableApiFp(this.configuration).payableControllerInitializePremiumSubscriptionTransferSession(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayableApi
     */
    public payableControllerInitializeProductUploadSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig) {
        return PayableApiFp(this.configuration).payableControllerInitializeProductUploadSubscriptionTransferSession(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {Array<string>} productIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayableApi
     */
    public payableControllerInitializePromotionSubscriptionTransferSession(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig) {
        return PayableApiFp(this.configuration).payableControllerInitializePromotionSubscriptionTransferSession(planId, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} paymentReference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayableApi
     */
    public payableControllerVerifyPaymentSession(paymentReference: string, options?: RawAxiosRequestConfig) {
        return PayableApiFp(this.configuration).payableControllerVerifyPaymentSession(paymentReference, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerFetchPaymentMethods: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/payment/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePostAdSubscription: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('paymentControllerInitializePostAdSubscription', 'planId', planId)
            const localVarPath = `/v1/vendor/payment/initialize-product-upload-payment-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePremiumSubscription: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('paymentControllerInitializePremiumSubscription', 'planId', planId)
            const localVarPath = `/v1/vendor/payment/initialize-premium-payment-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePremiumSubscriptionTransferSession: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('paymentControllerInitializePremiumSubscriptionTransferSession', 'planId', planId)
            const localVarPath = `/v1/vendor/payment/initialize-premium-transfer-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializeProductUploadTransferSession: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('paymentControllerInitializeProductUploadTransferSession', 'planId', planId)
            const localVarPath = `/v1/vendor/payment/initialize-product-upload-transfer-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePromotionSubscription: async (planId: number, productIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('paymentControllerInitializePromotionSubscription', 'planId', planId)
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('paymentControllerInitializePromotionSubscription', 'productIds', productIds)
            const localVarPath = `/v1/vendor/payment/initialize-promotion-payment-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePromotionTransferSession: async (planId: number, productIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('paymentControllerInitializePromotionTransferSession', 'planId', planId)
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('paymentControllerInitializePromotionTransferSession', 'productIds', productIds)
            const localVarPath = `/v1/vendor/payment/initialize-promotion-transfer-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerVerifyBankPaymentTransfer: async (paymentReference: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentReference' is not null or undefined
            assertParamExists('paymentControllerVerifyBankPaymentTransfer', 'paymentReference', paymentReference)
            const localVarPath = `/v1/vendor/payment/verify-payment-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paymentReference !== undefined) {
                localVarQueryParameter['paymentReference'] = paymentReference;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerVerifyPaymentSession: async (paymentReference: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentReference' is not null or undefined
            assertParamExists('paymentControllerVerifyPaymentSession', 'paymentReference', paymentReference)
            const localVarPath = `/v1/vendor/payment/verify-payment-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paymentReference !== undefined) {
                localVarQueryParameter['paymentReference'] = paymentReference;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerFetchPaymentMethods(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerFetchPaymentMethods(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerFetchPaymentMethods']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerInitializePostAdSubscription(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializePaymentSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerInitializePostAdSubscription(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerInitializePostAdSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerInitializePremiumSubscription(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializePaymentSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerInitializePremiumSubscription(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerInitializePremiumSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerInitializePremiumSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerInitializePremiumSubscriptionTransferSession(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerInitializePremiumSubscriptionTransferSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerInitializeProductUploadTransferSession(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerInitializeProductUploadTransferSession(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerInitializeProductUploadTransferSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerInitializePromotionSubscription(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializePaymentSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerInitializePromotionSubscription(planId, productIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerInitializePromotionSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerInitializePromotionTransferSession(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerInitializePromotionTransferSession(planId, productIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerInitializePromotionTransferSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerVerifyBankPaymentTransfer(paymentReference: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyPaymentSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerVerifyBankPaymentTransfer(paymentReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerVerifyBankPaymentTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentControllerVerifyPaymentSession(paymentReference: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyPaymentSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerVerifyPaymentSession(paymentReference, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.paymentControllerVerifyPaymentSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerFetchPaymentMethods(options?: RawAxiosRequestConfig): AxiosPromise<Array<PaymentMethod>> {
            return localVarFp.paymentControllerFetchPaymentMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePostAdSubscription(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<InitializePaymentSessionResponse> {
            return localVarFp.paymentControllerInitializePostAdSubscription(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePremiumSubscription(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<InitializePaymentSessionResponse> {
            return localVarFp.paymentControllerInitializePremiumSubscription(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePremiumSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChargeResponse> {
            return localVarFp.paymentControllerInitializePremiumSubscriptionTransferSession(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializeProductUploadTransferSession(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChargeResponse> {
            return localVarFp.paymentControllerInitializeProductUploadTransferSession(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePromotionSubscription(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<InitializePaymentSessionResponse> {
            return localVarFp.paymentControllerInitializePromotionSubscription(planId, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId 
         * @param {Array<string>} productIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerInitializePromotionTransferSession(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<ChargeResponse> {
            return localVarFp.paymentControllerInitializePromotionTransferSession(planId, productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerVerifyBankPaymentTransfer(paymentReference: string, options?: RawAxiosRequestConfig): AxiosPromise<VerifyPaymentSessionResponse> {
            return localVarFp.paymentControllerVerifyBankPaymentTransfer(paymentReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} paymentReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentControllerVerifyPaymentSession(paymentReference: string, options?: RawAxiosRequestConfig): AxiosPromise<VerifyPaymentSessionResponse> {
            return localVarFp.paymentControllerVerifyPaymentSession(paymentReference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerFetchPaymentMethods(options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerFetchPaymentMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerInitializePostAdSubscription(planId: number, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerInitializePostAdSubscription(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerInitializePremiumSubscription(planId: number, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerInitializePremiumSubscription(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerInitializePremiumSubscriptionTransferSession(planId: number, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerInitializePremiumSubscriptionTransferSession(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerInitializeProductUploadTransferSession(planId: number, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerInitializeProductUploadTransferSession(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {Array<string>} productIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerInitializePromotionSubscription(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerInitializePromotionSubscription(planId, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId 
     * @param {Array<string>} productIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerInitializePromotionTransferSession(planId: number, productIds: Array<string>, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerInitializePromotionTransferSession(planId, productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} paymentReference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerVerifyBankPaymentTransfer(paymentReference: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerVerifyBankPaymentTransfer(paymentReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} paymentReference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentControllerVerifyPaymentSession(paymentReference: string, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).paymentControllerVerifyPaymentSession(paymentReference, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PremiumSubscriptionApi - axios parameter creator
 * @export
 */
export const PremiumSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} plan Plan ID
         * @param {CreatePremiumSubscriptionDto} createPremiumSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerCreatePremiumSubscription: async (plan: number, createPremiumSubscriptionDto: CreatePremiumSubscriptionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('premiumSubscriptionControllerCreatePremiumSubscription', 'plan', plan)
            // verify required parameter 'createPremiumSubscriptionDto' is not null or undefined
            assertParamExists('premiumSubscriptionControllerCreatePremiumSubscription', 'createPremiumSubscriptionDto', createPremiumSubscriptionDto)
            const localVarPath = `/v1/vendor/premium-subscription/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPremiumSubscriptionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerFetchPremiumSubscriptionPlans: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/premium-subscription/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerFetchUserPremiumSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/premium-subscription/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerRegisterSubscriptionInquiry: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/premium-subscription/register-inquiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} plan Plan ID
         * @param {PremiumSubscriptionUpdateVendorProfileDto} premiumSubscriptionUpdateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerUpdateVendorProfile: async (plan: number, premiumSubscriptionUpdateVendorProfileDto: PremiumSubscriptionUpdateVendorProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('premiumSubscriptionControllerUpdateVendorProfile', 'plan', plan)
            // verify required parameter 'premiumSubscriptionUpdateVendorProfileDto' is not null or undefined
            assertParamExists('premiumSubscriptionControllerUpdateVendorProfile', 'premiumSubscriptionUpdateVendorProfileDto', premiumSubscriptionUpdateVendorProfileDto)
            const localVarPath = `/v1/vendor/premium-subscription/update-vendor-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(premiumSubscriptionUpdateVendorProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PremiumSubscriptionApi - functional programming interface
 * @export
 */
export const PremiumSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PremiumSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} plan Plan ID
         * @param {CreatePremiumSubscriptionDto} createPremiumSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premiumSubscriptionControllerCreatePremiumSubscription(plan: number, createPremiumSubscriptionDto: CreatePremiumSubscriptionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremiumSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premiumSubscriptionControllerCreatePremiumSubscription(plan, createPremiumSubscriptionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PremiumSubscriptionApi.premiumSubscriptionControllerCreatePremiumSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premiumSubscriptionControllerFetchPremiumSubscriptionPlans(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PremiumSubscriptionPlanDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premiumSubscriptionControllerFetchPremiumSubscriptionPlans(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PremiumSubscriptionApi.premiumSubscriptionControllerFetchPremiumSubscriptionPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premiumSubscriptionControllerFetchUserPremiumSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremiumSubscriptionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premiumSubscriptionControllerFetchUserPremiumSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PremiumSubscriptionApi.premiumSubscriptionControllerFetchUserPremiumSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premiumSubscriptionControllerRegisterSubscriptionInquiry(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premiumSubscriptionControllerRegisterSubscriptionInquiry(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PremiumSubscriptionApi.premiumSubscriptionControllerRegisterSubscriptionInquiry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} plan Plan ID
         * @param {PremiumSubscriptionUpdateVendorProfileDto} premiumSubscriptionUpdateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premiumSubscriptionControllerUpdateVendorProfile(plan: number, premiumSubscriptionUpdateVendorProfileDto: PremiumSubscriptionUpdateVendorProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premiumSubscriptionControllerUpdateVendorProfile(plan, premiumSubscriptionUpdateVendorProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PremiumSubscriptionApi.premiumSubscriptionControllerUpdateVendorProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PremiumSubscriptionApi - factory interface
 * @export
 */
export const PremiumSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PremiumSubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @param {number} plan Plan ID
         * @param {CreatePremiumSubscriptionDto} createPremiumSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerCreatePremiumSubscription(plan: number, createPremiumSubscriptionDto: CreatePremiumSubscriptionDto, options?: RawAxiosRequestConfig): AxiosPromise<PremiumSubscriptionResponse> {
            return localVarFp.premiumSubscriptionControllerCreatePremiumSubscription(plan, createPremiumSubscriptionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerFetchPremiumSubscriptionPlans(options?: RawAxiosRequestConfig): AxiosPromise<Array<PremiumSubscriptionPlanDescription>> {
            return localVarFp.premiumSubscriptionControllerFetchPremiumSubscriptionPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerFetchUserPremiumSubscription(options?: RawAxiosRequestConfig): AxiosPromise<PremiumSubscriptionInfo> {
            return localVarFp.premiumSubscriptionControllerFetchUserPremiumSubscription(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerRegisterSubscriptionInquiry(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.premiumSubscriptionControllerRegisterSubscriptionInquiry(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} plan Plan ID
         * @param {PremiumSubscriptionUpdateVendorProfileDto} premiumSubscriptionUpdateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premiumSubscriptionControllerUpdateVendorProfile(plan: number, premiumSubscriptionUpdateVendorProfileDto: PremiumSubscriptionUpdateVendorProfileDto, options?: RawAxiosRequestConfig): AxiosPromise<VendorInfo> {
            return localVarFp.premiumSubscriptionControllerUpdateVendorProfile(plan, premiumSubscriptionUpdateVendorProfileDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PremiumSubscriptionApi - object-oriented interface
 * @export
 * @class PremiumSubscriptionApi
 * @extends {BaseAPI}
 */
export class PremiumSubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {number} plan Plan ID
     * @param {CreatePremiumSubscriptionDto} createPremiumSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PremiumSubscriptionApi
     */
    public premiumSubscriptionControllerCreatePremiumSubscription(plan: number, createPremiumSubscriptionDto: CreatePremiumSubscriptionDto, options?: RawAxiosRequestConfig) {
        return PremiumSubscriptionApiFp(this.configuration).premiumSubscriptionControllerCreatePremiumSubscription(plan, createPremiumSubscriptionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PremiumSubscriptionApi
     */
    public premiumSubscriptionControllerFetchPremiumSubscriptionPlans(options?: RawAxiosRequestConfig) {
        return PremiumSubscriptionApiFp(this.configuration).premiumSubscriptionControllerFetchPremiumSubscriptionPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PremiumSubscriptionApi
     */
    public premiumSubscriptionControllerFetchUserPremiumSubscription(options?: RawAxiosRequestConfig) {
        return PremiumSubscriptionApiFp(this.configuration).premiumSubscriptionControllerFetchUserPremiumSubscription(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PremiumSubscriptionApi
     */
    public premiumSubscriptionControllerRegisterSubscriptionInquiry(options?: RawAxiosRequestConfig) {
        return PremiumSubscriptionApiFp(this.configuration).premiumSubscriptionControllerRegisterSubscriptionInquiry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} plan Plan ID
     * @param {PremiumSubscriptionUpdateVendorProfileDto} premiumSubscriptionUpdateVendorProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PremiumSubscriptionApi
     */
    public premiumSubscriptionControllerUpdateVendorProfile(plan: number, premiumSubscriptionUpdateVendorProfileDto: PremiumSubscriptionUpdateVendorProfileDto, options?: RawAxiosRequestConfig) {
        return PremiumSubscriptionApiFp(this.configuration).premiumSubscriptionControllerUpdateVendorProfile(plan, premiumSubscriptionUpdateVendorProfileDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerCreateProduct: async (createProductDto: CreateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductDto' is not null or undefined
            assertParamExists('vendorProductControllerCreateProduct', 'createProductDto', createProductDto)
            const localVarPath = `/v1/vendor/products/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerDeleteProduct: async (productId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('vendorProductControllerDeleteProduct', 'productId', productId)
            const localVarPath = `/v1/vendor/products/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerFetchProducts: async (page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('vendorProductControllerFetchProducts', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('vendorProductControllerFetchProducts', 'pageSize', pageSize)
            const localVarPath = `/v1/vendor/products/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerUpdateProduct: async (productId: number, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('vendorProductControllerUpdateProduct', 'productId', productId)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('vendorProductControllerUpdateProduct', 'updateProductDto', updateProductDto)
            const localVarPath = `/v1/vendor/products/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProductControllerCreateProduct(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProductControllerCreateProduct(createProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.vendorProductControllerCreateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProductControllerDeleteProduct(productId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProductControllerDeleteProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.vendorProductControllerDeleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProductControllerFetchProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProductControllerFetchProducts(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.vendorProductControllerFetchProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProductControllerUpdateProduct(productId: number, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProductControllerUpdateProduct(productId, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.vendorProductControllerUpdateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProductDto} createProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerCreateProduct(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductInfo> {
            return localVarFp.vendorProductControllerCreateProduct(createProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerDeleteProduct(productId: number, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.vendorProductControllerDeleteProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerFetchProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductsResponse> {
            return localVarFp.vendorProductControllerFetchProducts(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProductControllerUpdateProduct(productId: number, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductInfo> {
            return localVarFp.vendorProductControllerUpdateProduct(productId, updateProductDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {CreateProductDto} createProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public vendorProductControllerCreateProduct(createProductDto: CreateProductDto, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).vendorProductControllerCreateProduct(createProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public vendorProductControllerDeleteProduct(productId: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).vendorProductControllerDeleteProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page Page
     * @param {number} pageSize Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public vendorProductControllerFetchProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).vendorProductControllerFetchProducts(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product Id
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public vendorProductControllerUpdateProduct(productId: number, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).vendorProductControllerUpdateProduct(productId, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductUploadSubscriptionApi - axios parameter creator
 * @export
 */
export const ProductUploadSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} plan Plan ID
         * @param {CreateProductUploadSubscriptionDto} createProductUploadSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan: async (plan: number, createProductUploadSubscriptionDto: CreateProductUploadSubscriptionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan', 'plan', plan)
            // verify required parameter 'createProductUploadSubscriptionDto' is not null or undefined
            assertParamExists('productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan', 'createProductUploadSubscriptionDto', createProductUploadSubscriptionDto)
            const localVarPath = `/v1/vendor/product-upload/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductUploadSubscriptionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/product-upload/plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUploadSubscriptionControllerFetchUserProductUploadSubscription: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/product-upload/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductUploadSubscriptionApi - functional programming interface
 * @export
 */
export const ProductUploadSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductUploadSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} plan Plan ID
         * @param {CreateProductUploadSubscriptionDto} createProductUploadSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan(plan: number, createProductUploadSubscriptionDto: CreateProductUploadSubscriptionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan(plan, createProductUploadSubscriptionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductUploadSubscriptionApi.productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductUploadSubscriptionPlanInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductUploadSubscriptionApi.productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUploadSubscriptionControllerFetchUserProductUploadSubscription(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductUploadSubscriptionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUploadSubscriptionControllerFetchUserProductUploadSubscription(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductUploadSubscriptionApi.productUploadSubscriptionControllerFetchUserProductUploadSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductUploadSubscriptionApi - factory interface
 * @export
 */
export const ProductUploadSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductUploadSubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @param {number} plan Plan ID
         * @param {CreateProductUploadSubscriptionDto} createProductUploadSubscriptionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan(plan: number, createProductUploadSubscriptionDto: CreateProductUploadSubscriptionDto, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan(plan, createProductUploadSubscriptionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan(options?: RawAxiosRequestConfig): AxiosPromise<ProductUploadSubscriptionPlanInfo> {
            return localVarFp.productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUploadSubscriptionControllerFetchUserProductUploadSubscription(options?: RawAxiosRequestConfig): AxiosPromise<ProductUploadSubscriptionInfo> {
            return localVarFp.productUploadSubscriptionControllerFetchUserProductUploadSubscription(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductUploadSubscriptionApi - object-oriented interface
 * @export
 * @class ProductUploadSubscriptionApi
 * @extends {BaseAPI}
 */
export class ProductUploadSubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {number} plan Plan ID
     * @param {CreateProductUploadSubscriptionDto} createProductUploadSubscriptionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUploadSubscriptionApi
     */
    public productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan(plan: number, createProductUploadSubscriptionDto: CreateProductUploadSubscriptionDto, options?: RawAxiosRequestConfig) {
        return ProductUploadSubscriptionApiFp(this.configuration).productUploadSubscriptionControllerCreateProductUploadSubscriptionPlan(plan, createProductUploadSubscriptionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUploadSubscriptionApi
     */
    public productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan(options?: RawAxiosRequestConfig) {
        return ProductUploadSubscriptionApiFp(this.configuration).productUploadSubscriptionControllerFetchProductUploadSubscriptionPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUploadSubscriptionApi
     */
    public productUploadSubscriptionControllerFetchUserProductUploadSubscription(options?: RawAxiosRequestConfig) {
        return ProductUploadSubscriptionApiFp(this.configuration).productUploadSubscriptionControllerFetchUserProductUploadSubscription(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerFetchVendorProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/profile/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateVendorProfileDto} updateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerUpdateUserRole: async (updateVendorProfileDto: UpdateVendorProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVendorProfileDto' is not null or undefined
            assertParamExists('vendorProfileControllerUpdateUserRole', 'updateVendorProfileDto', updateVendorProfileDto)
            const localVarPath = `/v1/vendor/profile/me/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateVendorProfileDto} updateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerUpdateVendorProfile: async (updateVendorProfileDto: UpdateVendorProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVendorProfileDto' is not null or undefined
            assertParamExists('vendorProfileControllerUpdateVendorProfile', 'updateVendorProfileDto', updateVendorProfileDto)
            const localVarPath = `/v1/vendor/profile/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateVendorProfileLogoDto} updateVendorProfileLogoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerUpdateVendorProfileLogo: async (updateVendorProfileLogoDto: UpdateVendorProfileLogoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVendorProfileLogoDto' is not null or undefined
            assertParamExists('vendorProfileControllerUpdateVendorProfileLogo', 'updateVendorProfileLogoDto', updateVendorProfileLogoDto)
            const localVarPath = `/v1/vendor/profile/me/logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVendorProfileLogoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProfileControllerFetchVendorProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProfileControllerFetchVendorProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.vendorProfileControllerFetchVendorProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateVendorProfileDto} updateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProfileControllerUpdateUserRole(updateVendorProfileDto: UpdateVendorProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProfileControllerUpdateUserRole(updateVendorProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.vendorProfileControllerUpdateUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateVendorProfileDto} updateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProfileControllerUpdateVendorProfile(updateVendorProfileDto: UpdateVendorProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProfileControllerUpdateVendorProfile(updateVendorProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.vendorProfileControllerUpdateVendorProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateVendorProfileLogoDto} updateVendorProfileLogoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vendorProfileControllerUpdateVendorProfileLogo(updateVendorProfileLogoDto: UpdateVendorProfileLogoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vendorProfileControllerUpdateVendorProfileLogo(updateVendorProfileLogoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.vendorProfileControllerUpdateVendorProfileLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerFetchVendorProfile(options?: RawAxiosRequestConfig): AxiosPromise<VendorInfo> {
            return localVarFp.vendorProfileControllerFetchVendorProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateVendorProfileDto} updateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerUpdateUserRole(updateVendorProfileDto: UpdateVendorProfileDto, options?: RawAxiosRequestConfig): AxiosPromise<UpdateUserRoleResponse> {
            return localVarFp.vendorProfileControllerUpdateUserRole(updateVendorProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateVendorProfileDto} updateVendorProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerUpdateVendorProfile(updateVendorProfileDto: UpdateVendorProfileDto, options?: RawAxiosRequestConfig): AxiosPromise<VendorInfo> {
            return localVarFp.vendorProfileControllerUpdateVendorProfile(updateVendorProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateVendorProfileLogoDto} updateVendorProfileLogoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vendorProfileControllerUpdateVendorProfileLogo(updateVendorProfileLogoDto: UpdateVendorProfileLogoDto, options?: RawAxiosRequestConfig): AxiosPromise<VendorInfo> {
            return localVarFp.vendorProfileControllerUpdateVendorProfileLogo(updateVendorProfileLogoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public vendorProfileControllerFetchVendorProfile(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).vendorProfileControllerFetchVendorProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateVendorProfileDto} updateVendorProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public vendorProfileControllerUpdateUserRole(updateVendorProfileDto: UpdateVendorProfileDto, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).vendorProfileControllerUpdateUserRole(updateVendorProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateVendorProfileDto} updateVendorProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public vendorProfileControllerUpdateVendorProfile(updateVendorProfileDto: UpdateVendorProfileDto, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).vendorProfileControllerUpdateVendorProfile(updateVendorProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateVendorProfileLogoDto} updateVendorProfileLogoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public vendorProfileControllerUpdateVendorProfileLogo(updateVendorProfileLogoDto: UpdateVendorProfileLogoDto, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).vendorProfileControllerUpdateVendorProfileLogo(updateVendorProfileLogoDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromotionSubscriptionApi - axios parameter creator
 * @export
 */
export const PromotionSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePromotionDto} createPromotionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerCreatePromotionSubscription: async (createPromotionDto: CreatePromotionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPromotionDto' is not null or undefined
            assertParamExists('promotionSubscriptionControllerCreatePromotionSubscription', 'createPromotionDto', createPromotionDto)
            const localVarPath = `/v1/vendor/promotions/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromotionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} productIds Product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchProductsInfo: async (productIds: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('promotionSubscriptionControllerFetchProductsInfo', 'productIds', productIds)
            const localVarPath = `/v1/vendor/promotions/products-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productIds !== undefined) {
                localVarQueryParameter['productIds'] = productIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchPromotionPlans: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/promotions/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page Page number
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchUserProducts: async (page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('promotionSubscriptionControllerFetchUserProducts', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('promotionSubscriptionControllerFetchUserProducts', 'pageSize', pageSize)
            const localVarPath = `/v1/vendor/promotions/products/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchUserPromotionPlan: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/promotions/plan/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchUserPromotions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/promotions/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} planId Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerUpdateUserPromotionPlan: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('promotionSubscriptionControllerUpdateUserPromotionPlan', 'planId', planId)
            const localVarPath = `/v1/vendor/promotions/plan/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromotionSubscriptionApi - functional programming interface
 * @export
 */
export const PromotionSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromotionSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePromotionDto} createPromotionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerCreatePromotionSubscription(createPromotionDto: CreatePromotionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerCreatePromotionSubscription(createPromotionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerCreatePromotionSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} productIds Product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerFetchProductsInfo(productIds: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VendorProductInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerFetchProductsInfo(productIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerFetchProductsInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerFetchPromotionPlans(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromotionPlanDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerFetchPromotionPlans(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerFetchPromotionPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page Page number
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerFetchUserProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VendorProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerFetchUserProducts(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerFetchUserProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerFetchUserPromotionPlan(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPromotionPlanInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerFetchUserPromotionPlan(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerFetchUserPromotionPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerFetchUserPromotions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerFetchUserPromotions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerFetchUserPromotions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} planId Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promotionSubscriptionControllerUpdateUserPromotionPlan(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPromotionPlanInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promotionSubscriptionControllerUpdateUserPromotionPlan(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromotionSubscriptionApi.promotionSubscriptionControllerUpdateUserPromotionPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromotionSubscriptionApi - factory interface
 * @export
 */
export const PromotionSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromotionSubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePromotionDto} createPromotionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerCreatePromotionSubscription(createPromotionDto: CreatePromotionDto, options?: RawAxiosRequestConfig): AxiosPromise<PromotionInfo> {
            return localVarFp.promotionSubscriptionControllerCreatePromotionSubscription(createPromotionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} productIds Product IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchProductsInfo(productIds: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VendorProductInfo>> {
            return localVarFp.promotionSubscriptionControllerFetchProductsInfo(productIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchPromotionPlans(options?: RawAxiosRequestConfig): AxiosPromise<Array<PromotionPlanDescription>> {
            return localVarFp.promotionSubscriptionControllerFetchPromotionPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page Page number
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchUserProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<VendorProductsResponse> {
            return localVarFp.promotionSubscriptionControllerFetchUserProducts(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchUserPromotionPlan(options?: RawAxiosRequestConfig): AxiosPromise<UserPromotionPlanInfo> {
            return localVarFp.promotionSubscriptionControllerFetchUserPromotionPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerFetchUserPromotions(options?: RawAxiosRequestConfig): AxiosPromise<PromotionsInfo> {
            return localVarFp.promotionSubscriptionControllerFetchUserPromotions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} planId Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promotionSubscriptionControllerUpdateUserPromotionPlan(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserPromotionPlanInfo> {
            return localVarFp.promotionSubscriptionControllerUpdateUserPromotionPlan(planId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromotionSubscriptionApi - object-oriented interface
 * @export
 * @class PromotionSubscriptionApi
 * @extends {BaseAPI}
 */
export class PromotionSubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {CreatePromotionDto} createPromotionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerCreatePromotionSubscription(createPromotionDto: CreatePromotionDto, options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerCreatePromotionSubscription(createPromotionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} productIds Product IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerFetchProductsInfo(productIds: string, options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerFetchProductsInfo(productIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerFetchPromotionPlans(options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerFetchPromotionPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page Page number
     * @param {number} pageSize Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerFetchUserProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerFetchUserProducts(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerFetchUserPromotionPlan(options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerFetchUserPromotionPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerFetchUserPromotions(options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerFetchUserPromotions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} planId Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionSubscriptionApi
     */
    public promotionSubscriptionControllerUpdateUserPromotionPlan(planId: number, options?: RawAxiosRequestConfig) {
        return PromotionSubscriptionApiFp(this.configuration).promotionSubscriptionControllerUpdateUserPromotionPlan(planId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerPayableWebhookSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/vendor/payable/payable-callback-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payableControllerPayableWebhookSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payableControllerPayableWebhookSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.payableControllerPayableWebhookSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payableControllerPayableWebhookSession(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.payableControllerPayableWebhookSession(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public payableControllerPayableWebhookSession(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).payableControllerPayableWebhookSession(options).then((request) => request(this.axios, this.basePath));
    }
}



